<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
	<head>

		<!--
			Copyright (c) 2013 Antoine Martin <antoine@devloop.org.uk>
			Licensed under MPL 2.0
 		-->

		<title>xpra websockets client</title>
		<meta http-equiv="content-type" content="text/html; charset=iso-8859-15" />
		<meta name="description" content="xpra websockets client" />
		<link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
		<link rel="icon" type="image/png" href="/favicon.png" />

		<style>
			body {
				background-color: #708090;
			}
			canvas {
				border : 1px solid black;
				display: none;
			}
		</style>

		<script type="text/javascript" src="include/websock.js"></script>
		<script type="text/javascript" src="include/bencode.js"></script>
		<script type="text/javascript" src="include/inflate.min.js"></script>
		<script type="text/javascript" src="include/protocol.js"></script>
		<script type="text/javascript" src="include/keycodes.js"></script>
		<script type="text/javascript" src="include/shapes.js"></script>
		<script type="text/javascript" src="include/window.js"></script>
		<script type="text/javascript" src="include/util.js"></script>

		<script type="text/javascript">
			var protocol;

			var id_to_window = {};
			var window_to_id = {};
			var focus = -1;

			var OLD_ENCODING_NAMES_TO_NEW = {"x264" : "h264", "vpx" : "vp8"};
			var RGB_FORMATS = ["RGBX", "RGBA"];
			var canvas_state = null;

			var caps_lock = null;
			var alt_modifier = null;
			var meta_modifier = null;

			function get_modifiers(event) {
				"use strict";
				//convert generic modifiers "meta" and "alt" into their x11 name:
				var modifiers = get_event_modifiers(event);
				//FIXME: look them up!
				var alt = "mod1";
				var meta = "mod1";
				var index = modifiers.indexOf("alt");
				if (index>=0)
					modifiers[index] = alt;
				index = modifiers.indexOf("meta");
				if (index>=0)
					modifiers[index] = meta;
				return modifiers;
			}

			function processKeyEvent(pressed, event) {
				"use strict";
				if (canvas_state==null)
					return;
				// MSIE hack
				if (window.event)
					event = window.event;
				//show("processKeyEvent("+pressed+", "+event+") keyCode="+event.keyCode+", charCode="+event.charCode+", which="+event.which);

				var keyname = "";
				var keycode = 0;
				if (event.which)
					keycode = event.which;
				else
					keycode = event.keyCode;
				if (keycode in CHARCODE_TO_NAME)
					keyname = CHARCODE_TO_NAME[keycode];
				var DOM_KEY_LOCATION_RIGHT = 2;
				if (keyname.match("_L$") && event.location==DOM_KEY_LOCATION_RIGHT)
					keyname = keyname.replace("_L", "_R")

				var modifiers = get_event_modifiers(event);
				if (caps_lock)
					modifiers.push("lock");
				var keyval = keycode;
				var str = String.fromCharCode(event.which);
				var group = 0;

				var shift = modifiers.indexOf("shift")>=0;
				if ((caps_lock && shift) || (!caps_lock && !shift))
					str = str.toLowerCase();

				var win = canvas_state.topOfStack();
				if (win != null) {
					//show("win="+win.toSource()+", keycode="+keycode+", modifiers=["+modifiers+"], str="+str);
					var wid = window_to_id[win];
					var packet = ["key-action", wid, keyname, pressed, modifiers, keyval, str, keycode, group];
					send(packet);
				}
			}

			function onkeydown(event) {
				"use strict";
				processKeyEvent(true, event);
				return false;
			};
			function onkeyup(event) {
				"use strict";
				processKeyEvent(false, event);
				return false;
			};
			function onkeypress(event) {
				"use strict";
				var keycode = 0;
				if (event.which)
					keycode = event.which;
				else
					keycode = event.keyCode;
				var modifiers = get_event_modifiers(event);

				/* PITA: this only works for keypress event... */
				caps_lock = false;
				var shift = modifiers.indexOf("shift")>=0;
				if (keycode>=97 && keycode<=122 && shift)
					caps_lock = true;
				else if (keycode>=65 && keycode<=90 && !shift)
					caps_lock = true;
				//show("caps_lock="+caps_lock);
				return false;
			};

			function show(text) {
				"use strict";
				console.log(text);
				var msg = document.getElementById("message")
				msg.innerHTML = msg.innerHTML + "<br />" + text;
			}
			function error(text) {
				"use strict";
				console.log(text);
				var msg = document.getElementById("message")
				msg.innerHTML = msg.innerHTML + "<br />" + text;
			}

			function process_startup_complete(packet) {
				"use strict";
				show("startup complete");
			}
			function process_hello(packet) {
				"use strict";
				//show("process_hello("+packet+")");
				var hello = packet[1];
				var version = hello["version"];
				try {
					var vparts = version.split(".");
					var vno = [];
					for (var i=0; i<vparts.length;i++) {
						vno[i] = parseInt(vparts[i]);
					}
					if (vno[0]<=0 && vno[1]<10) {
						show("unsupported version: "+version);
						stop();
						return;
					}
				}
				catch (e) {
					show("error parsing version number '"+version+"'");
					stop();
					return;
				}
				show("got hello: server version "+version+" accepted our connection")
				//figure out "alt" and "meta" keys:
				if ("modifier_keycodes" in hello) {
					var modifier_keycodes = hello["modifier_keycodes"];
					for (var mod in modifier_keycodes) {
						//show("modifier_keycode["+mod+"]="+modifier_keycodes[mod].toSource());
						var keys = modifier_keycodes[mod];
						for (var i=0; i<keys.length; i++) {
							var key = keys[i];
							//the first value is usually the integer keycode,
							//the second one is the actual key name,
							//doesn't hurt to test both:
							for (var j=0; j<key.length; j++) {
								if ("Alt_L"==key[j])
									alt_modifier = mod;
								if ("Meta_L"==key[j])
									meta_modifier = mod;
							}
						}
					}
				}
				//show("alt="+alt_modifier+", meta="+meta_modifier);
			}
			function process_disconnect(packet) {
				"use strict";
				reason = packet[1];
				window.alert("Disconnected: "+reason);
			}
			function process_ping(packet) {
				"use strict";
				var echotime = packet[1];
				var l1=0, l2=0, l3=0;
				send(["ping_echo", echotime, l1, l2, l3, 0]);
			}

			function process_bell(packet) {
				//TODO!
			}

			function window_geometry_changed(win) {
				"use strict";
				//show("window_geometry_changed("+win+") geometry="+win.get_window_geometry().toSource());
				var geom = win.get_internal_geometry();
				var wid = window_to_id[win];
				if (!win.override_redirect)
					self.set_focus(wid);
				send(["configure-window", wid, geom.x, geom.y, geom.w, geom.h, get_client_properties()]);
			};
			function mouse_move(win, x, y, modifiers, buttons) {
				"use strict";
				var wid = window_to_id[win];
				send(["pointer-position", wid, [x, y], modifiers, buttons]);
			};
			function mouse_click(win, button, pressed, x, y, modifiers, buttons) {
				"use strict";
				var wid = window_to_id[win];
				//show("mouse_click(..) wid("+win+")="+wid);
				check_focus();
				send(["button-action", wid, button, pressed, [x, y], modifiers, buttons]);
			};

			function check_focus() {
				"use strict";
				var wid = -1;
				var win = canvas_state.topOfStack();
				if (win != null)
					wid = window_to_id[win];
				//show("check_focus() window_to_id["+win+"]="+wid+", focus="+wid+", window_to_id="+window_to_id.toSource());
				if (wid!=focus)
					set_focus(wid);
			}

			function set_focus(wid) {
				"use strict";
				focus = wid;
				send(["focus", focus, []]);
				//set the focused flag on all windows:
				for (var i=0; i<window_to_id.length; i++) {
					window_to_id[i].focused = (window_to_id[i]==win);
				}
			}

			function get_client_properties(win) {
				"use strict";
				return {"encodings.rgb_formats" : RGB_FORMATS};
			};

			function make_new_window(wid, x, y, w, h, metadata, override_redirect, client_properties) {
				"use strict";
				var win = new XpraWindow(canvas_state, wid, x, y, w, h, metadata, override_redirect, client_properties,
						window_geometry_changed, mouse_move, mouse_click);
				//show("make_new_window("+wid+", "+x+", "+y+", "+w+", "+h+", "+metadata+", "+override_redirect+", "+client_properties+")="+win);
				id_to_window[wid] = win;
				window_to_id[win] = wid;
				var geom = win.get_internal_geometry();
				if (!override_redirect) {
					send(["map-window", wid, geom.x, geom.y, geom.w, geom.h, get_client_properties()]);
					set_focus(wid);
				}
			}

			function process_new_common(packet, override_redirect) {
				"use strict";
				var wid, x, y, w, h, metadata;
				wid = packet[1];
				x = packet[2];
				y = packet[3];
				w = packet[4];
				h = packet[5];
				metadata = packet[6];
				if (wid in id_to_window)
					throw "we already have a window " + wid;
				if (w<=0 || h<=0) {
					error("window dimensions are wrong: "+w+"x"+h);
					w, h = 1, 1
				}
				var client_properties = {}
				if (packet.length>=8)
					client_properties = packet[7];
				make_new_window(wid, x, y, w, h, metadata, override_redirect, client_properties)
			}

			function process_new_window(packet) {
				"use strict";
				process_new_common(packet, false);
			}

			function process_new_override_redirect(packet) {
				"use strict";
				process_new_common(packet, true);
			}


			function send_damage_sequence(wid, packet_sequence, width, height, decode_time) {
				"use strict";
				send(["damage-sequence", packet_sequence, wid, width, height, decode_time]);
			}

			function process_draw(packet) {
				"use strict";
				var start = new Date().getTime(),
					wid = packet[1],
					x = packet[2],
					y = packet[3],
					width = packet[4],
					height = packet[5],
					coding = packet[6],
					data = packet[7],
					packet_sequence = packet[8],
					rowstride = packet[9],
					options = {};
				
				if (packet.length>10)
					options = packet[10];
				if (coding in OLD_ENCODING_NAMES_TO_NEW)
					coding = OLD_ENCODING_NAMES_TO_NEW[coding];
				var win = id_to_window[wid];
				var decode_time = -1;
				if (win) {
					win.paint(x, y, width, height, coding, data, packet_sequence, rowstride, options);
					decode_time = new Date().getTime() - start;
				}
				send_damage_sequence(wid, packet_sequence, width, height, decode_time);
			}

			function process_lost_window(packet) {
				"use strict";
				var wid = packet[1];
				var win = id_to_window[wid];
				if (win!=null) {
					win.destroy();
					check_focus();
				}
			}

			function process_raise_window(packet) {
				"use strict";
				var wid = packet[1];
				var win = id_to_window[wid];
				if (win!=null) {
					canvas_state.raiseShape(win);
					focus = wid;
					check_focus();
				}
			}

			function process_window_resized(packet) {
				//TODO
			}
			function process_window_icon(packet) {
				//TODO
			}
			function process_window_metadata(packet) {
				//TODO
			}
			function process_new_tray(packet) {
				//TODO
			}
			function process_cursor(packet) {
				//TODO
				//setcursor("default")
			}
			function process_desktop_size(packet) {
				//TODO
			}
			function process_clipboard_token(packet) {
				//TODO
			}


			function guess_platform() {
				"use strict";
				//use python style strings for platforms:
				if (navigator.appVersion.indexOf("Win")!=-1)
					return "win32";
				if (navigator.appVersion.indexOf("Mac")!=-1)
					return "darwin";
				if (navigator.appVersion.indexOf("Linux")!=-1)
					return "linux2";
				if (navigator.appVersion.indexOf("X11")!=-1)
					return "posix";
				return "unknown";
			}
			function guess_platform_name() {
				"use strict";
				//use python style strings for platforms:
				if (navigator.appVersion.indexOf("Win")!=-1)
					return "Microsoft Windows";
				if (navigator.appVersion.indexOf("Mac")!=-1)
					return "Mac OSX";
				if (navigator.appVersion.indexOf("Linux")!=-1)
					return "Linux";
				if (navigator.appVersion.indexOf("X11")!=-1)
					return "Posix";
				return "unknown";
			}
			function guess_platform_processor() {
				"use strict";
				//mozilla property:
				if (navigator.oscpu)
					return navigator.oscpu;
				//ie:
				if (navigator.cpuClass)
					return navigator.cpuClass;
				return "unknown";
			}
			function get_DPI() {
				"use strict";
				var dpi_div = document.getElementById("dpi");
				if (dpi_div != undefined) {
					//show("dpiX="+dpi_div.offsetWidth+", dpiY="+dpi_div.offsetHeight);
					if (dpi_div.offsetWidth>0 && dpi_div.offsetHeight>0)
						return Math.round((dpi_div.offsetWidth + dpi_div.offsetHeight) / 2.0);
				}
				//alternative:
				if ('deviceXDPI' in screen)
					return (screen.systemXDPI + screen.systemYDPI) / 2;
				//default:
				return 96;
			}

			function get_keyboard_layout() {
				"use strict";
				//IE:
				//navigator.systemLanguage
				//navigator.browserLanguage
				var v = window.navigator.userLanguage || window.navigator.language;
				//ie: v="en_GB";
				v = v.split(",")[0];
				var l = v.split("-", 2);
				if (l.length==1)
					l = v.split("_", 2);
				if (l.length==1)
					return "";
				//ie: "gb"
				return l[1].toLowerCase();
			}

			function get_desktop_size() {
				"use strict";
				var canvas = document.getElementById('screen');
				return [canvas.width, canvas.height];
			}
			function get_screen_sizes() {
				"use strict";
				var canvas = document.getElementById('screen');
				var dpi = get_DPI();
				/*
				equivallent GTK code:
				monitor = plug_name, geom.x, geom.y, geom.width, geom.height, wmm, hmm
				monitors.append(monitor)

				screen = (screen.make_display_name(), screen.get_width(), screen.get_height(),
						screen.get_width_mm(), screen.get_height_mm(),
						monitors,
						work_x, work_y, work_width, work_height)
				*/
				var wmm = Math.round(canvas.width*25.4/dpi);
				var hmm = Math.round(canvas.height*25.4/dpi);
				var monitor = ["Canvas", 0, 0, canvas.width, canvas.height, wmm, hmm];
				var screen = ["HTML", canvas.width, canvas.height,
							wmm, hmm,
							[monitor],
							0, 0, canvas.width, canvas.height
						];
				//just a single screen:
				return [screen];
			}

			function get_keycodes() {
				"use strict";
				//keycodes.append((nn(keyval), nn(name), nn(keycode), nn(group), nn(level)))
				var keycodes = [];
				var kc;
				for(var keycode in CHARCODE_TO_NAME) {
					kc = parseInt(keycode);
					keycodes.push([kc, CHARCODE_TO_NAME[keycode], kc, 0, 0]);
				}
				//show("keycodes="+keycodes.toSource());
				return keycodes;
			}

			function make_hello() {
				"use strict";
				return	{
						"version"					: "0.11.0",
						"platform"					: guess_platform(),
						"platform.name"				: guess_platform_name(),
						"platform.processor"		: guess_platform_processor(),
						"platform.platform"			: navigator.appVersion,
						"namespace"			 		: true,
						"client_type"		   		: "HTML5",
						"share"						: false,
						"auto_refresh_delay"		: 500,
						"randr_notify"				: true,
						"sound.server_driven"		: true,
						"generic_window_types"		: true,
						"server-window-resize"		: true,
						"notify-startup-complete"	: true,
						"generic-rgb-encodings"		: true,
						"window.raise"				: true,
						"encodings"					: ["rgb"],
						"raw_window_icons"			: true,
						//rgb24 is not efficient in HTML so don't use it:
						//png and jpeg will need extra code
						//"encodings.core"			: ["rgb24", "rgb32", "png", "jpeg"],
						"encodings.core"			: ["rgb32"],
						"encodings.rgb_formats"	 	: RGB_FORMATS,
						"encoding.generic"	  		: true,
						"encoding.transparency"		: true,
						"encoding.client_options"	: true,
						"encoding.csc_atoms"		: true,
						"encoding.uses_swscale"		: false,
						//video stuff we may handle later:
						"encoding.video_reinit"		: false,
						"encoding.video_scaling"	: false,
						"encoding.csc_modes"		: [],
						//sound (not yet):
						"sound.receive"				: false,
						"sound.send"				: false,
						//compression bits:
						"zlib"						: true,
						"lz4"						: false,
						"compression_level"	 		: 1,
						"compressible_cursors"		: true,
						"encoding.rgb24zlib"		: true,
						"encoding.rgb_zlib"			: true,
						"encoding.rgb_lz4"			: false,
						"windows"					: true,
						//partial support:
						"keyboard"					: true,
						"xkbmap_layout"				: get_keyboard_layout(),
						"xkbmap_keycodes"			: get_keycodes(),
						"desktop_size"				: get_desktop_size(),
						"screen_sizes"				: get_screen_sizes(),
						"dpi"						: get_DPI(),
						//not handled yet, but we will:
						"clipboard_enabled"			: false,
						"notifications"				: true,
						"cursors"					: true,
						"bell"						: true,
						"system_tray"				: true,
						//we cannot handle this (GTK only):
						"named_cursors"				: false,
						}
			}

			function send(packet) {
				"use strict";
				if (protocol!=null) {
					try {
						protocol.send(packet);
					}
					catch(e) {
						show("error sending packet: "+e);
						this.stop();
					}
				}
			}

			function start() {
				"use strict";
				show("start()");
				document.onkeydown = onkeydown;
				document.onkeyup = onkeyup;
				document.onkeypress = onkeypress;

				var canvas = document.getElementById('screen');
				canvas.style.display = "block";

				if (canvas_state==null)
					canvas_state = new CanvasState(canvas);
				protocol = new Protocol();
				protocol.set_packet_handler("open", process_open);
				protocol.set_packet_handler("close", process_close);
				protocol.set_packet_handler("error", process_error);
				var uri = "ws://localhost:8080/";
				protocol.open(uri);
				show("opening connection to "+uri);
			}
			function stop() {
				"use strict";
				show("stop()");
				id_to_window = {};
				window_to_id = {};
				focus = -1;
				document.onkeydown = null;
				document.onkeyup = null;
				document.onkeypress = null;
				if (protocol!=null) {
					protocol.close();
					protocol = null;
				}
				if (canvas_state!=null) {
					canvas_state.destroy();
					canvas_state = null;
				}
				var canvas = document.getElementById('screen');
				canvas.style.display = "none";
			}
			function process_close(packet) {
				"use strict";
				show("process_close("+packet+")");
				stop();
			}
			function process_error(packet) {
				"use strict";
				show("process_error("+packet+")");
				stop();
			}
			function process_open(packet) {
				"use strict";
				show("connected to server - sending hello");
				var packet_handlers = {
					"startup-complete"		: process_startup_complete,
					"hello"					: process_hello,
					"disconnect"			: process_disconnect,
					"ping"					: process_ping,
					"cursor"				: process_cursor,
					"new-window"			: process_new_window,
					"new-override-redirect"	: process_new_override_redirect,
					"new-tray"				: process_new_tray,
					"draw"					: process_draw,
					"window-metadata"		: process_window_metadata,
					"lost-window"			: process_lost_window,
					"window-resized"		: process_window_resized,
					"window-icon"			: process_window_icon,
					"raise-window"			: process_raise_window,
					"desktop_size"			: process_desktop_size,
					"bell"					: process_bell,
					"clipboard-token"		: process_clipboard_token,
					};
				for (var packet_type in packet_handlers) {
					protocol.set_packet_handler(packet_type, packet_handlers[packet_type]);
				}

				var hello = make_hello();
				//show("hello="+hello);
				send(["hello", hello]);
			}

			function force_refresh() {
				"use strict";
				if (protocol!=null) {
					send(["buffer-refresh", -1, true, 95]);
				}
			}

			function new_popup() {
				"use strict";
				var newwindow = window.open('./index.html?connect=true', 'xpra',
				        'height=800px,width=600px,location=no,menubar=no,scrollbars=no,status=no,titlebar=no,toolbar=no');
				if (window.focus) {
					newwindow.focus();
				}
			}

			function init() {
				"use strict";
				show("init()");
				// add a large green rectangle
				// s.addShape(new Shape(s, 260, 70, 60, 65, 'rgba(0,205,0,0.7)'));
				// add a green-blue rectangle
				// s.addShape(new Shape(s, 240, 120, 40, 40, 'rgba(2,165,165,0.7)'));
				// add a smaller purple rectangle
				// s.addShape(new Shape(s, 5, 60, 25, 25, 'rgba(150,150,250,0.7)'));
				if (window.location.getParameter("connect")=="true") {
					start();
				}
			}

		</script>
	</head>

	<body onload="init()">
		<div>
			<form onsubmit="return false;">
				<fieldset>
				<button id="connect" onclick="start();">Connect</button>
				<button id="disconnect" onclick="stop();">Disconnect</button>
				<button id="refresh" onclick="force_refresh();">Refresh</button>
				<button id="popup" onclick="new_popup();">Popup</button>
				<br />
				</fieldset>
				<canvas id="screen" width="1024" height="600"></canvas>
			</form>
		</div>
		<div id="message">
		</div>
		<div id="dpi" style="width: 1in; height: 1in; left: -100%; top: -100%; position: absolute;">
		</div>
	</body>
</html>
