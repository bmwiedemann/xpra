<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
	<head>

		<!--
			Copyright (c) 2013 Antoine Martin <antoine@devloop.org.uk>
			Licensed under MPL 2.0
 		-->

		<title>xpra websockets client</title>
		<meta http-equiv="content-type" content="text/html; charset=iso-8859-15" />
		<meta name="description" content="xpra websockets client" />
		<link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
		<link rel="icon" type="image/png" href="/favicon.png" />

		<style>
			canvas {
				border : 1px solid black;
			}
		</style>

		<script type="text/javascript" src="include/websock.js"></script>
		<script type="text/javascript" src="include/bencode.js"></script>
		<script type="text/javascript" src="include/inflate.min.js"></script>
		<script type="text/javascript" src="include/protocol.js"></script>
		<script type="text/javascript" src="include/keycodes.js"></script>
		<script type="text/javascript" src="include/shapes.js"></script>
		<script type="text/javascript" src="include/window.js"></script>

		<script type="text/javascript">
			var protocol;

			var id_to_window = {};
			var window_to_id = {};
			var focus = -1;

			var OLD_ENCODING_NAMES_TO_NEW = {"x264" : "h264", "vpx" : "vp8"};
			var RGB_FORMATS = ["RGBX", "RGBA"];
			var canvas_state = null;

			var caps_lock = null;
			var alt_modifier = null;
			var meta_modifier = null;

			function get_modifiers(event) {
				//convert generic modifiers "meta" and "alt" into their x11 name:
				var modifiers = get_event_modifiers(event);
				//FIXME: look them up!
				var alt = "mod1";
				var meta = "mod1";
				var index = modifiers.indexOf("alt");
				if (index>=0)
					modifiers[index] = alt;
				index = modifiers.indexOf("meta");
				if (index>=0)
					modifiers[index] = meta;
				return modifiers;
			}

			processKeyEvent = function(pressed, event) {
				if (canvas_state==null)
					return;
				// MSIE hack
				if (window.event)
					event = window.event;
				//show("processKeyEvent("+pressed+", "+event+") keyCode="+event.keyCode+", charCode="+event.charCode+", which="+event.which);

				var keyname = "";
				var keycode = 0;
				if (event.which)
					keycode = event.which;
				else
					keycode = event.keyCode;
				if (keycode in CHARCODE_TO_NAME)
					keyname = CHARCODE_TO_NAME[keycode];
				var DOM_KEY_LOCATION_RIGHT = 2;
				if (keyname.match("_L$") && event.location==DOM_KEY_LOCATION_RIGHT)
					keyname = keyname.replace("_L", "_R")

				var modifiers = get_event_modifiers(event);
				if (caps_lock)
					modifiers.push("lock");
				var keyval = keycode;
				var str = String.fromCharCode(event.which);
				var group = 0;

				var shift = modifiers.indexOf("shift")>=0;
				if ((caps_lock && shift) || (!caps_lock && !shift))
					str = str.toLowerCase();

				var win = canvas_state.topOfStack();
				if (win != null) {
					//show("win="+win.toSource()+", keycode="+keycode+", modifiers=["+modifiers+"], str="+str);
					var wid = window_to_id[win];
					packet = ["key-action", wid, keyname, pressed, modifiers, keyval, str, keycode, group];
					send(packet);
				}
			}

			document.onkeydown = function(event) {
				processKeyEvent(true, event);
			};
			document.onkeyup = function(event) {
				processKeyEvent(false, event);
			};
			document.onkeypress = function(event) {
				var keycode = 0;
				if (event.which)
					keycode = event.which;
				else
					keycode = event.keyCode;
				var modifiers = get_event_modifiers(event);

				/* PITA: this only works for keypress event... */
				caps_lock = false;
				var shift = modifiers.indexOf("shift")>=0;
				if (keycode>=97 && keycode<=122 && shift)
					caps_lock = true;
				else if (keycode>=65 && keycode<=90 && !shift)
					caps_lock = true;
				//show("caps_lock="+caps_lock);
			};

			function show(text) {
				console.log(text);
				var msg = document.getElementById("message")
				msg.innerHTML = msg.innerHTML + "<br />" + text;
			}
			function error(text) {
				console.log(text);
				var msg = document.getElementById("message")
				msg.innerHTML = msg.innerHTML + "<br />" + text;
			}

			function process_startup_complete(packet) {
				show("startup complete");
			}
			function process_hello(packet) {
				//show("process_hello("+packet+")");
				show("got hello: server accepted our connection")
				var hello = packet[1];
				//figure out "alt" and "meta" keys: 
				if ("modifier_keycodes" in hello) {
					var modifier_keycodes = hello["modifier_keycodes"];
					for (var mod in modifier_keycodes) {
						//show("modifier_keycode["+mod+"]="+modifier_keycodes[mod].toSource());
						var keys = modifier_keycodes[mod];
						for (var i=0; i<keys.length; i++) {
							var key = keys[i];
							//the first value is usually the integer keycode,
							//the second one is the actual key name,
							//doesn't hurt to test both:
							for (var j=0; j<key.length; j++) {
								if ("Alt_L"==key[j])
									alt_modifier = mod;
								if ("Meta_L"==key[j])
									meta_modifier = mod;
							}
						}
					}
				}
				//show("alt="+alt_modifier+", meta="+meta_modifier);
			}
			function process_disconnect(packet) {
				reason = packet[1];
				window.alert("Disconnected: "+reason);
			}
			function process_ping(packet) {
				var echotime = packet[1];
				var l1=0, l2=0, l3=0;
				send(["ping_echo", echotime, l1, l2, l3, 0]);
			}

			function process_bell(packet) {
				//TODO!
			}

			function process_new_common(packet, override_redirect) {
				var wid, x, y, w, h, metadata;
				wid = packet[1];
				x = packet[2];
				y = packet[3];
				w = packet[4];
				h = packet[5];
				metadata = packet[6];
				if (wid in id_to_window)
					throw "we already have a window " + wid;
				if (w<=0 || h<=0) {
					error("window dimensions are wrong: "+w+"x"+h);
					w, h = 1, 1
				}
				client_properties = {}
				if (packet.length>=8)
					client_properties = packet[7];
				this.make_new_window(wid, x, y, w, h, metadata, override_redirect, client_properties)
			}

			function window_geometry_changed(win) {
				//show("window_geometry_changed("+win+") geometry="+win.get_window_geometry().toSource());
				var geom = win.get_internal_geometry();
				var wid = window_to_id[win];
				send(["configure-window", wid, geom.x, geom.y, geom.w, geom.h, get_client_properties()]);
			};
			function mouse_move(win, x, y, modifiers, buttons) {
				var wid = window_to_id[win];
				send(["pointer-position", wid, [x, y], modifiers, buttons]);
			};
			function mouse_click(win, button, pressed, x, y, modifiers, buttons) {
				var wid = window_to_id[win];
				check_focus();
				send(["button-action", wid, button, pressed, [x, y], modifiers, buttons]);
			};

			function check_focus() {
				var wid = -1;
				var win = canvas_state.topOfStack();
				if (win != null)
					wid = window_to_id[win];
				//show("check_focus() wid="+wid+", focus="+wid);
				if (wid!=focus) {
					focus = wid;
					send(["focus", focus, []]);
				}
			}

			function get_client_properties(win) {
				return {"encodings.rgb_formats" : RGB_FORMATS};
			};

			function make_new_window(wid, x, y, w, h, metadata, override_redirect, client_properties) {
				var win = new XpraWindow(canvas_state, x, y, w, h, metadata, override_redirect, client_properties,
						window_geometry_changed, mouse_move, mouse_click);
				//show("make_new_window("+wid+", "+x+", "+y+", "+w+", "+h+", "+metadata+", "+override_redirect+", "+client_properties+")="+window);
				id_to_window[wid] = win;
				window_to_id[win] = wid;
				geom = win.get_internal_geometry();
				send(["map-window", wid, geom.x, geom.y, geom.w, geom.h, get_client_properties()]);
				focus = wid;
				send(["focus", focus, []]);
			}

			function process_new_window(packet) {
				process_new_common(packet, false);
			}

			function process_new_override_redirect(packet) {
				process_new_common(packet, true);
			}


			function send_damage_sequence(wid, packet_sequence, width, height, decode_time) {
				send(["damage-sequence", packet_sequence, wid, width, height, decode_time]);
			}

			function process_draw(packet) {
				var start = new Date().getTime();
				wid = packet[1];
				x = packet[2];
				y = packet[3];
				width = packet[4];
				height = packet[5];
				coding = packet[6];
				data = packet[7];
				packet_sequence = packet[8];
				rowstride = packet[9];
				if (packet.length>10)
					options = packet[10];
				else
					options = {};
				if (coding in OLD_ENCODING_NAMES_TO_NEW)
					coding = OLD_ENCODING_NAMES_TO_NEW[coding];
				var win = id_to_window[wid];
				var decode_time = -1;
				if (win) {
					win.paint(x, y, width, height, coding, data, packet_sequence, rowstride, options);
					decode_time = new Date().getTime() - start;
				}
				this.send_damage_sequence(wid, packet_sequence, width, height, decode_time);
			}

			function process_lost_window(packet) {
				var wid = packet[1];
				var win = id_to_window[wid];
				if (win!=null) {
					win.destroy();
					check_focus();
				}
			}

			function process_window_resized(packet) {
				//TODO
			}
			function process_window_icon(packet) {
				//TODO
			}
			function process_window_metadata(packet) {
				//TODO
			}
			function process_new_tray(packet) {
				//TODO
			}
			function process_cursor(packet) {
				//TODO
				//setcursor("default")
			}
			function process_desktop_size(packet) {
				//TODO
			}


			function guess_platform() {
				//use python style strings for platforms:
				if (navigator.appVersion.indexOf("Win")!=-1)
					return "win32";
				if (navigator.appVersion.indexOf("Mac")!=-1)
					return "darwin";
				if (navigator.appVersion.indexOf("Linux")!=-1)
					return "linux2";
				if (navigator.appVersion.indexOf("X11")!=-1)
					return "posix";
				return "unknown";
			}
			function guess_platform_name() {
				//use python style strings for platforms:
				if (navigator.appVersion.indexOf("Win")!=-1)
					return "Microsoft Windows";
				if (navigator.appVersion.indexOf("Mac")!=-1)
					return "Mac OSX";
				if (navigator.appVersion.indexOf("Linux")!=-1)
					return "Linux";
				if (navigator.appVersion.indexOf("X11")!=-1)
					return "Posix";
				return "unknown";
			}
			function guess_platform_processor() {
				//mozilla property:
				if (navigator.oscpu)
					return navigator.oscpu;
				//ie:
				if (navigator.cpuClass)
					return navigator.cpuClass;
				return "unknown";
			}
			function get_DPI() {
				var dpi_div = document.getElementById("dpi");
				if (dpi_div != undefined) {
					//show("dpiX="+dpi_div.offsetWidth+", dpiY="+dpi_div.offsetHeight);
					if (dpi_div.offsetWidth>0 && dpi_div.offsetHeight>0)
						return Math.round((dpi_div.offsetWidth + dpi_div.offsetHeight) / 2.0);
				}
				//alternative:
				if ('deviceXDPI' in screen)
					return (screen.systemXDPI + screen.systemYDPI) / 2;
				//default:
				return 96;
			}

			function get_keyboard_layout() {
				//IE:
				//navigator.systemLanguage
				//navigator.browserLanguage
				var v = window.navigator.userLanguage || window.navigator.language;
				//ie: v="en_GB";
				v = v.split(",")[0];
				var l = v.split("-", 2);
				if (l.length==1)
					l = v.split("_", 2);
				if (l.length==1)
					return "";
				//ie: "gb"
				return l[1].toLowerCase();
			}

			function get_desktop_size() {
				var canvas = document.getElementById('screen');
				return [canvas.width, canvas.height];
			}
			function get_screen_sizes() {
				var canvas = document.getElementById('screen');
				var dpi = get_DPI();
				/*
				equivallent GTK code:
				monitor = plug_name, geom.x, geom.y, geom.width, geom.height, wmm, hmm
				monitors.append(monitor)

				screen = (screen.make_display_name(), screen.get_width(), screen.get_height(),
						screen.get_width_mm(), screen.get_height_mm(),
						monitors,
						work_x, work_y, work_width, work_height)
				*/
				var wmm = Math.round(canvas.width*25.4/dpi);
				var hmm = Math.round(canvas.height*25.4/dpi);
				var monitor = ["Canvas", 0, 0, canvas.width, canvas.height, wmm, hmm];
				var screen = ["HTML", canvas.width, canvas.height,
							wmm, hmm,
							[monitor],
							0, 0, canvas.width, canvas.height
						];
				//just a single screen:
				return [screen];
			}

			function get_keycodes() {
				//keycodes.append((nn(keyval), nn(name), nn(keycode), nn(group), nn(level)))
				var keycodes = [];
				var kc;
				for(var keycode in CHARCODE_TO_NAME) {
					kc = parseInt(keycode);
					keycodes.push([kc, CHARCODE_TO_NAME[keycode], kc, 0, 0]);
				}
				//show("keycodes="+keycodes.toSource());
				return keycodes;
			}

			function make_hello() {
				return	{
						"version"					: "0.11.0",
						"platform"					: guess_platform(),
						"platform.name"				: guess_platform_name(),
						"platform.processor"		: guess_platform_processor(),
						"platform.platform"			: navigator.appVersion,
						"namespace"			 		: true,
						"raw_window_icons"			: true,
						"client_type"		   		: "HTML5",
						"share"						: false,
						"compression_level"	 		: 0,
						"auto_refresh_delay"		: 500,
						"window.raise"				: true,
						"randr_notify"				: true,
						"sound.server_driven"		: true,
						"generic_window_types"		: true,
						"server-window-resize"		: true,
						"notify-startup-complete"	: true,
						"generic-rgb-encodings"		: true,
						"encodings"					: ["rgb", "png", "jpeg"],
						//rgb24 is not efficient in HTML so don't use it:
						//png and jpeg will need extra code
						//"encodings.core"			: ["rgb24", "rgb32", "png", "jpeg"],
						"encodings.core"			: ["rgb32"],
						"encodings.rgb_formats"	 	: RGB_FORMATS,
						"encoding.generic"	  		: true,
						"encoding.transparency"		: true,
						"encoding.client_options"	: true,
						"encoding.csc_atoms"		: true,
						"encoding.uses_swscale"		: false,
						//video stuff we may handle later:
						"encoding.video_reinit"		: false,
						"encoding.video_scaling"	: false,
						"encoding.csc_modes"		: [],
						//we need zlib and lz4:
						"zlib"						: true,
						"compressible_cursors"		: true,
						"encoding.rgb24zlib"		: true,
						"rgb24zlib"					: true,
						"lz4"						: false,
						"encoding.rgb_lz4"			: false,
						"windows"					: true,
						//disabled for now:
						"keyboard"					: true,
						"xkbmap_layout"				: get_keyboard_layout(),
						"xkbmap_keycodes"			: get_keycodes(),
						"desktop_size"				: get_desktop_size(),
						"screen_sizes"				: get_screen_sizes(),
						"dpi"						: get_DPI(),
						//not handled yet, but we will:
						"notifications"				: true,
						"cursors"					: true,
						"bell"						: true,
						"system_tray"				: true,
						//we cannot handle this (GTK only):
						"named_cursors"				: false,
						}
			}

			function send(packet) {
				if (protocol!=null) {
					try {
						protocol.send(packet);
					}
					catch(e) {
						show("error sending packet: "+e);
						this.stop();
					}
				}
			}

			function start() {
				show("start()");
				if (canvas_state==null)
					canvas_state = new CanvasState(document.getElementById('screen'));
				protocol = new Protocol();
				protocol.set_packet_handler("open", process_open);
				protocol.set_packet_handler("close", process_close);
				protocol.set_packet_handler("error", process_error);
				var uri = "ws://localhost:8080/";
				protocol.open(uri);
				show("opening connection to "+uri);
			}
			function stop() {
				show("stop()");
				id_to_window = {};
				window_to_id = {};
				focus = -1;
				if (protocol!=null) {
					protocol.close();
					protocol = null;
				}
				if (canvas_state!=null) {
					canvas_state.destroy();
					canvas_state = null;
				}
			}
			function process_close(packet) {
				show("process_close("+packet+")");
				stop();
			}
			function process_error(packet) {
				show("process_error("+packet+")");
				stop();
			}
			function process_open(packet) {
				show("connected to server - sending hello");
				var packet_handlers = {
					"startup-complete"		: process_startup_complete,
					"hello"					: process_hello,
					"disconnect"			: process_disconnect,
					"ping"					: process_ping,
					"cursor"				: process_cursor,
					"new-window"			: process_new_window,
					"new-override-redirect"	: process_new_override_redirect,
					"new-tray"				: process_new_tray,
					"draw"					: process_draw,
					"window-metadata"		: process_window_metadata,
					"lost-window"			: process_lost_window,
					"window-resized"		: process_window_resized,
					"window-icon"			: process_window_icon,
					"desktop_size"			: process_desktop_size,
					"bell"					: process_bell,
					};
				for (var packet_type in packet_handlers) {
					protocol.set_packet_handler(packet_type, packet_handlers[packet_type]);
				}

				var hello = make_hello();
				//show("hello="+hello);
				send(["hello", hello]);
			}

			function force_refresh() {
				if (protocol!=null) {
					send(["buffer-refresh", -1, true, 95]);
				}
			}

			function init() {
				"use strict";
				show("init()");
				// add a large green rectangle
				// s.addShape(new Shape(s, 260, 70, 60, 65, 'rgba(0,205,0,0.7)'));
				// add a green-blue rectangle
				// s.addShape(new Shape(s, 240, 120, 40, 40, 'rgba(2,165,165,0.7)'));
				// add a smaller purple rectangle
				// s.addShape(new Shape(s, 5, 60, 25, 25, 'rgba(150,150,250,0.7)'));
			}

		</script>
	</head>

	<body onload="init()">
		<div>
			<form onsubmit="return false;">
				<fieldset>
				<button id="connect" onclick="start();">Connect</button>
				<button id="disconnect" onclick="stop();">Disconnect</button>
				<button id="refresh" onclick="force_refresh();">Refresh</button>
				<br />
				</fieldset>
				<canvas id="screen" width="1024" height="600"></canvas>
			</form>
		</div>
		<div id="message">
		</div>
		<div id="dpi" style="width: 1in; height: 1in; left: -100%; top: -100%; position: absolute;">
		</div>
	</body>
</html>
